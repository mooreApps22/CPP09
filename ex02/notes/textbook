
I have used a std::map and std::stack for ex00 and ex01. So ex02 can used as many c++98 containers that are not those two. Write a PmergeMe and base on this infomation.


This is the subject for the assignment:

Chapter VI
Exercise 02: PmergeMe
Exercise : 02
PmergeMe
Turn-in directory : ex02/
Files to turn in : Makefile, main.cpp, PmergeMe.{cpp, hpp}
Forbidden functions : None
You must create a program with these constraints:
• The name of the program is PmergeMe.
• Your program must be able to use a positive integer sequence as argument.
• Your program must use the merge-insert sort algorithm to sort the positive integer
sequence.
To clarify, yes, you need to use the Ford-Johnson algorithm.
(source: Art Of Computer Programming, Vol.3. Merge Insertion,
Page 184.)
• If an error occurs during program execution, an error message should be displayed
on the standard error.
You must use at least two different containers in your code to
validate this exercise. Your program must be able to handle at
least 3000 different integers.
10C++ - Module 09
STL
It is strongly advised to implement your algorithm for each container
and thus to avoid using a generic function.
Here are some additional guidelines on the information you should display line by line
on the standard output:
• On the first line you must display an explicit text followed by the unsorted positive
integer sequence.
• On the second line you must display an explicit text followed by the sorted positive
integer sequence.
• On the third line you must display an explicit text indicating the time used by
your algorithm by specifying the first container used to sort the positive integer
sequence.
• On the last line you must display an explicit text indicating the time used by
your algorithm by specifying the second container used to sort the positive integer
sequence.
The format for the display of the time used to carry out your sorting
is free but the precision chosen must allow to clearly see the
difference between the two containers used.
Here is an example of a standard use:
$> ./PmergeMe 3 5 9 7 4
Before: 3 5 9 7 4
After:
3 4 5 7 9
Time to process a range of 5 elements with std::[..] : 0.00031 us
Time to process a range of 5 elements with std::[..] : 0.00014 us
$> ./PmergeMe `shuf -i 1-100000 -n 3000 | tr "\n" " "`
Before: 141 79 526 321 [...]
After:
79 141 321 526 [...]
Time to process a range of 3000 elements with std::[..] : 62.14389 us
Time to process a range of 3000 elements with std::[..] : 69.27212 us
$> ./PmergeMe "-1" "2"
Error
$> # For OSX USER:
$> ./PmergeMe `jot -r 3000 1 100000 | tr '\n' ' '`
[...]
$>
The indication of the time is deliberately strange in this example.
Of course you have to indicate the time used to perform all your
operations, both the sorting part and the data management part.
11C++ - Module 09
STL
Warning: The container(s) you used in the previous exercises are
forbidden here.
The management of errors related to duplicates is left to your
discretion.


This is an excerpt from the Textbook : Art Of Computer Programming, Vol.3. Merge Insertion,
Page 184. This is the an algorithm I have to understand and implement in C++98 for the 42 London CPP09/ex02 exercise. This project has constaints which include I have to used a list and deque. Those are the only containers I'm allowed to use. (Some of the excerpt's figures didn't copy perfectly.) Please, summerize this Merge insertion algorithm as simply as possible for the most reasonably basic explanation possible. I have tried reading this and let just say I'm confused.:)


Merge insertion. A pleasant generalization of the method above has been
discovered by Lester Ford, Jr. and Selmer Johnson. Since it involves some aspects
of merging and some aspects of insertion, we shall call it merge insertion. For
example, consider the problem of sorting 21 elements. We start by comparing
the ten pairs K 1 : K 2, K3: K4, ... , K19: K2o; then we sort the ten larger elements
of the pairs, using merge insertion. As a result we obtain the configuration
bi b2 b3 b4 b5 b5 b7 bs bg b10 bn
analogous to (5)· The next step is to insert b3 among {b1, a1, a2}, then b2 among
the other elements less than a2; we arrive at the configuration
C3 C4 C5
>• 7 7 7 7 7 7 7. >• >• >• (8)
b4 b5 b5 b7 bs bg bio bn
Let us call the upper-line elements the main chain. We can insert b5 into its
proper place in the main chain, using three comparisons (first comparing it to
c4, then c2 or c6 , etc.); then b4 can be moved into the main chain in three more
steps, leading to
di d2 d3 d4 d5 d5 d7 ds dg dio a5 a7 as ag aio
• >• >• >• >• >• >• >• >• >• 7 7 7 7 7 •
(g)
b5 b7 bs bg bio bn
The next step is crucial; is it clear what to do? We insert bu (not b7 ) into the
main chain, using only four comparisons. Then b10 , b9 , b8 , b7 , b6 (in this order)
can also be inserted into their proper places in the main chain, using at most
four comparisons each.
A careful count of the comparisons involved here shows that the 21 elements
have been sorted in at most 10+ S(lO) + 2 + 2 + 3 + 3 +4+ 4+4 +4+ 4+4 = 66 
5.3.1 MINIMUM-COMPARISON SORTING 185
steps. Since
265 < 21! < 266'
we also know that no fewer than 66 would be possible in any event; hence
S(21) = 66. (io)
(Binary insertion would have required 7 4 comparisons.)
In general, merge insertion proceeds as follows for n elements:
i) Make pairwise comparisons of l n / 2 J disjoint pairs of elements. (If n is odd,
leave one element out.)
ii) Sort the ln/2J larger numbers, found in step (i), by merge insertion.
iii) Name the elements a1, a2, ... , aln/2J, b1, b2, ... , bln/21 as in (1), where a1 <
a2 ::::; · · · ::::; aln/2J and bi ::::; ai for 1 ::::; i ::::; l n/2 J; call b1 and the a's the
"main chain." Insert the remaining b's into the main chain, using binary
insertion, in the following order, leaving out all bj for j > r n/21:
b3,b2; b5,b4; b11,b10, ... ,b5; ... ; btk,btk-1, ... ,btk-1+1; .... (11)
We wish to define the sequence (t1, t2, t3, t4, ... ) = (1, 3, 5, 11, ... ), which
appears in (11), in such a way that each of btk' btk-1, ... , btk_ 1+1 can be inserted
into the main chain with at most k comparisons. Generalizing (1), (8), and (g),
we obtain the diagram
where the main chain up to and including atk-1 contains 2tk-l + (tk - tk-l - 1)
elements. This number must be less than 2k; our best bet is to set it equal to
2k - 1, so that
tk-l + tk = 2k. (i2)
Since t1 = 1, we may set t 0 = 1 for convenience, and we find that
tk = 2k - tk-l = 2k - 2k-l + tk-2 = ... = 2k - 2k-l + ... + (-l)k2°
= (2k+l + (-l)k) /3 (i3)
by summing a geometric series. (Curiously, this same sequence arose in our
study of an algorithm for calculating the greatest common divisor of two integers;
see exercise 4.5.2-36.)
Let F(n) be the number of comparisons required to sort n elements by merge
insertion. Clearly
F(n) = ln/2J + F(ln/2J) + G(\n/21),
where G represents the amount of work involved in step (iii). If tk-l ::::; m::::; tk,
we have
k-1
G(m) = Lj(tj - tj-1) + k(m - tk_i) =km - (to+ t1 + · · · + tk-1), (i5)
j=l 
186 SORTING 5.3.1
summing by parts. Let us set
Wk =to+ t1 + · · · + tk-l = l2k+l/3j, ( 16)
so that (w0 , w1 , w2, w3 , w4 , ... ) = (0, 1, 2, 5, 10, 21, ... ). Exercise 13 shows that
F(n)-F(n-l)=k if and only if . and the latter condition is equivalent to
2k+l 2k+2
--<n<-- 3 - 3 '
or k + 1 < lg3n S:·k + 2; hence
F ( n) - F ( n - 1) = flg ~ n l · ( 18)
(This formula is due to A. Hadian [Ph.D. thesis, Univ. of Minnesota (1969),
38-42].) It follows that F(n) has a remarkably simple expression,
n
F ( n) = L flg ~kl , ( 19)
k=l
quite similar to the corresponding formula (3) for binary insertion. A closed
form for this sum appears in exercise 14.
Equation (19) makes it easy to construct a table of F(n); we have
n = 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17
jlg n!l = 0 1 3 5 7 10 13 16 19 22 26 29 33 37 41 45 49
F( n) = O 1 3 5 7 10 13 16 19 22 26 30 34 38 42 46 50
n = 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33
\lg n!l = 53 57 62 66 70 75 80 84 89 94 98 103 108 113 118 123
F( n) = 54 58 62 66 71 76 81 86 91 96 101 106 111 116 121 126
Notice that F(n) = jlgn!l for 1S:nS:11 and for 20 S: n S: 21, so we know that
merge insertion is optimum for those n:
S ( n) = jlg n ! l = F ( n) for n = 1, ... , 11, 20, and 21.
Hugo Steinhaus posed the problem of finding S ( n) in the second edition of his
classic book Mathematical Snapshots (Oxford University Press, 1950), 38-39. He
described the method of binary insertion, which is the best possible way to sort n
objects if we start by sorting n -1 of them first before the nth is considered; and
he conjectured that binary insertion would be optimum in general. Several years
later [Calcutta Math. Soc. Golden Jubilee Commemoration 2 (1959), 323-327],
he reported that two of his colleagues, S. Trybula and P. Czen, had "recently"
disproved his conjecture, and that they had determined S(n) for n S: 11. Trybula
and Czen may have independently discovered the method of merge insertion,
which was published soon afterwards by Ford and Johnson [AM.l\!I 66 (1959),
387-389].
After the discovery of merge insertion, the first unknown value of S(n) was
S(12). Table 1 shows that 12! is quite close to 229, hence the existence of a 
5.3.1 MINIMUM-COMPARISON SORTING 187
Table 1
VALUES OF FACTORIALS IN BINARY NOTATION
(1)2 = 1!
(10)2 = 2!
(110)2 = 3!
(11000)2 = 4!
(1111000)2 = 5!
(1011010000)2 = 6!
(1001110110000)2 = 7!
(1001110110000000)2 = 8!
( 1011000100110000000 )2 = 9 !
(1101110101111100000000)2 = 10!
(10011000010001010100000000)2 = 11!
(11100100011001111110000000000)2 = 12!
(101110011001010001100110000000000)2 = 13!
(1010001001100001110110010100000000000)2 = 14!
(10011000001110111011101110101100000000000)2 = 15!
(100110000011101110111011101011000000000000000)2 = 16!
(1010000110111111011101110110011011000000000000000)2 = 17!
(10110101111101110110011001010011100110000000000000000)2 = 18!
(110110000001010111001001100000110100010010000000000000000)2 = 19!
(10000111000011011001110111110010000010101101000000000000000000)2 = 20!
29-step sorting procedure for 12 elements is somewhat unlikely. An exhaustive
search (about 60 hours on a Maniac II computer) was therefore carried out by
Mark Wells, who discovered that S(12) = 30 [Proc. IFIP Congress 65 2 (1965),
497-498; Elements of Combinatorial Computing (Pergamon, 1971), 213-215].
Thus the merge insertion procedure turns out to be optimum for n = 12 as well. 
